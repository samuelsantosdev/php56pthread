#!/opt/php-5.6.16/bin/php
<?php if (!class_exists('PHP_Archive')) {
?><?php
/**
 * PHP_Archive Class (implements .phar)
 *
 * @package PHP_Archive
 * @category PHP
 */
/**
 * PHP_Archive Class (implements .phar)
 *
 * PHAR files a singular archive from which an entire application can run.
 * To use it, simply package it using {@see PHP_Archive_Creator} and use phar://
 * URIs to your includes. i.e. require_once 'phar://config.php' will include config.php
 * from the root of the PHAR file.
 *
 * Gz code borrowed from the excellent File_Archive package by Vincent Lascaux.
 *
 * @copyright Copyright David Shafik and Synaptic Media 2004. All rights reserved.
 * @author Davey Shafik <davey@synapticmedia.net>
 * @author Greg Beaver <cellog@php.net>
 * @link http://www.synapticmedia.net Synaptic Media
 * @version $Id$
 * @package PHP_Archive
 * @category PHP
 */

class PHP_Archive
{
    const GZ = 0x00001000;
    const BZ2 = 0x00002000;
    const SIG = 0x00010000;
    const SHA1 = 0x0002;
    const MD5 = 0x0001;
    const SHA256 = 0x0003;
    const SHA512 = 0x0004;
    const OPENSSL = 0x0010;
    /**
     * Whether this archive is compressed with zlib
     *
     * @var bool
     */
    private $_compressed;
    /**
     * @var string Real path to the .phar archive
     */
    private $_archiveName = null;
    /**
     * Current file name in the phar
     * @var string
     */
    protected $currentFilename = null;
    /**
     * Length of current file in the phar
     * @var string
     */
    protected $internalFileLength = null;
    /**
     * true if the current file is an empty directory
     * @var string
     */
    protected $isDir = false;
    /**
     * Current file statistics (size, creation date, etc.)
     * @var string
     */
    protected $currentStat = null;
    /**
     * @var resource|null Pointer to open .phar
     */
    protected $fp = null;
    /**
     * @var int Current Position of the pointer
     */
    protected $position = 0;

    /**
     * Map actual realpath of phars to meta-data about the phar
     *
     * Data is indexed by the alias that is used by internal files.  In other
     * words, if a file is included via:
     * <code>
     * require_once 'phar://PEAR.phar/PEAR/Installer.php';
     * </code>
     * then the alias is "PEAR.phar"
     *
     * Information stored is a boolean indicating whether this .phar is compressed
     * with zlib, another for bzip2, phar-specific meta-data, and
     * the precise offset of internal files
     * within the .phar, used with the {@link $_manifest} to load actual file contents
     * @var array
     */
    private static $_pharMapping = array();
    /**
     * Map real file paths to alias used
     *
     * @var array
     */
    private static $_pharFiles = array();
    /**
     * File listing for the .phar
     *
     * The manifest is indexed per phar.
     *
     * Files within the .phar are indexed by their relative path within the
     * .phar.  Each file has this information in its internal array
     *
     * - 0 = uncompressed file size
     * - 1 = timestamp of when file was added to phar
     * - 2 = offset of file within phar relative to internal file's start
     * - 3 = compressed file size (actual size in the phar)
     * @var array
     */
    private static $_manifest = array();
    /**
     * Absolute offset of internal files within the .phar, indexed by absolute
     * path to the .phar
     *
     * @var array
     */
    private static $_fileStart = array();
    /**
     * file name of the phar
     *
     * @var string
     */
    private $_basename;


    /**
     * Default MIME types used for the web front controller
     *
     * @var array
     */
    public static $defaultmimes = array(
            'aif' => 'audio/x-aiff',
            'aiff' => 'audio/x-aiff',
            'arc' => 'application/octet-stream',
            'arj' => 'application/octet-stream',
            'art' => 'image/x-jg',
            'asf' => 'video/x-ms-asf',
            'asx' => 'video/x-ms-asf',
            'avi' => 'video/avi',
            'bin' => 'application/octet-stream',
            'bm' => 'image/bmp',
            'bmp' => 'image/bmp',
            'bz2' => 'application/x-bzip2',
            'css' => 'text/css',
            'doc' => 'application/msword',
            'dot' => 'application/msword',
            'dv' => 'video/x-dv',
            'dvi' => 'application/x-dvi',
            'eps' => 'application/postscript',
            'exe' => 'application/octet-stream',
            'gif' => 'image/gif',
            'gz' => 'application/x-gzip',
            'gzip' => 'application/x-gzip',
            'htm' => 'text/html',
            'html' => 'text/html',
            'ico' => 'image/x-icon',
            'jpe' => 'image/jpeg',
            'jpg' => 'image/jpeg',
            'jpeg' => 'image/jpeg',
            'js' => 'application/x-javascript',
            'log' => 'text/plain',
            'mid' => 'audio/x-midi',
            'mov' => 'video/quicktime',
            'mp2' => 'audio/mpeg',
            'mp3' => 'audio/mpeg3',
            'mpg' => 'audio/mpeg',
            'pdf' => 'aplication/pdf',
            'png' => 'image/png',
            'rtf' => 'application/rtf',
            'tif' => 'image/tiff',
            'tiff' => 'image/tiff',
            'txt' => 'text/plain',
            'xml' => 'text/xml',
        );

    public static $defaultphp = array(
        'php' => true
        );

    public static $defaultphps = array(
        'phps' => true
        );

    public static $deny = array('/.+\.inc$/');

    public static function viewSource($archive, $file)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (self::_fileExists($archive, $_GET['viewsource'])) {
            $source = highlight_file('phar://@ALIAS@/' .
                $_GET['viewsource'], true);
            header('Content-Type: text/html');
            header('Content-Length: ' . strlen($source));
            echo '<html><head><title>Source of ',
                htmlspecialchars($_GET['viewsource']), '</title></head>';
            echo '<body><h1>Source of ',
                htmlspecialchars($_GET['viewsource']), '</h1>';
            if (isset($_GET['introspect'])) {
                echo '<a href="', htmlspecialchars($_SERVER['PHP_SELF']),
                    '?introspect=', urlencode(htmlspecialchars($_GET['introspect'])),
                    '">Return to ', htmlspecialchars($_GET['introspect']), '</a><br />';
            }
            echo $source;
            return false;
        } else {
            header("HTTP/1.0 404 Not Found");
            return false;
        }

    }

    public static function introspect($archive, $dir)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (!$dir) {
            $dir = '/';
        }
        $dir = self::processFile($dir);
        if ($dir[0] != '/') {
            $dir = '/' . $dir;
        }
        try {
            $self = htmlspecialchars($_SERVER['PHP_SELF']);
            $iterate = new DirectoryIterator('phar://@ALIAS@' . $dir);
            echo '<html><head><title>Introspect ', htmlspecialchars($dir),
                '</title></head><body><h1>Introspect ', htmlspecialchars($dir),
                '</h1><ul>';
            if ($dir != '/') {
                echo '<li><a href="', $self, '?introspect=',
                    htmlspecialchars(dirname($dir)), '">..</a></li>';
            }
            foreach ($iterate as $entry) {
                if ($entry->isDot()) continue;
                $name = self::processFile($entry->getPathname());
                $name = str_replace('phar://@ALIAS@/', '', $name);
                if ($entry->isDir()) {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '/</a> [directory]</li>';
                } else {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($dir)), '&viewsource=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '</a></li>';
                }
            }
            return false;
        } catch (Exception $e) {
            echo '<html><head><title>Directory not found: ',
                htmlspecialchars($dir), '</title></head>',
                '<body><h1>Directory not found: ', htmlspecialchars($dir), '</h1>',
                '<p>Try <a href="', htmlspecialchars($_SERVER['PHP_SELF']), '?introspect=/">',
                'This link</a></p></body></html>';
            return false;
        }
    }

    public static function webFrontController($initfile)
    {
        if (isset($_SERVER) && isset($_SERVER['REQUEST_URI'])) {
            $uri = parse_url($_SERVER['REQUEST_URI']);
            $archive = realpath($_SERVER['SCRIPT_FILENAME']);
            $subpath = str_replace('/' . basename($archive), '', $uri['path']);
            if (!$subpath || $subpath == '/') {
                if (isset($_GET['viewsource'])) {
                    return self::viewSource($archive, $_GET['viewsource']);
                }
                if (isset($_GET['introspect'])) {
                    return self::introspect($archive, $_GET['introspect']);
                }
                $subpath = '/' . $initfile;
            }
            if (!self::_fileExists($archive, substr($subpath, 1))) {
                header("HTTP/1.0 404 Not Found");
                return false;
            }
            foreach (self::$deny as $pattern) {
                if (preg_match($pattern, $subpath)) {
                    header("HTTP/1.0 404 Not Found");
                    return false;
                }
            }
            $inf = pathinfo(basename($subpath));
            if (!isset($inf['extension'])) {
                header('Content-Type: text/plain');
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                return false;
            }
            if (isset(self::$defaultphp[$inf['extension']])) {
                include 'phar://@ALIAS@' . $subpath;
                return false;
            }
            if (isset(self::$defaultmimes[$inf['extension']])) {
                header('Content-Type: ' . self::$defaultmimes[$inf['extension']]);
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                return false;
            }
            if (isset(self::$defaultphps[$inf['extension']])) {
                header('Content-Type: text/html');
                $c = highlight_file('phar://@ALIAS@' . $subpath, true);
                header('Content-Length: ' . strlen($c));
                echo $c;
                return false;
            }
            header('Content-Type: text/plain');
            header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
            readfile('phar://@ALIAS@' . $subpath);
        }
    }

    /**
     * Detect end of stub
     *
     * @param string $buffer stub past '__HALT_'.'COMPILER();'
     * @return end of stub, prior to length of manifest.
     */
    private static final function _endOfStubLength($buffer)
    {
        $pos = 0;
        if (!strlen($buffer)) {
            return $pos;
        }
        if (($buffer[0] == ' ' || $buffer[0] == "\n") && @substr($buffer, 1, 2) == '?>')
        {
            $pos += 3;
            if ($buffer[$pos] == "\r" && $buffer[$pos+1] == "\n") {
                $pos += 2;
            }
            else if ($buffer[$pos] == "\n") {
                $pos += 1;
            }
        }
        return $pos;
    }

    /**
     * Allows loading an external Phar archive without include()ing it
     *
     * @param string $file  phar package to load
     * @param string $alias alias to use
     * @throws Exception
     */
    public static final function loadPhar($file, $alias = NULL)
    {
        $file = realpath($file);
        if ($file) {
            $fp = fopen($file, 'rb');
            $buffer = '';
            while (!feof($fp)) {
                $buffer .= fread($fp, 8192);
                // don't break phars
                if ($pos = strpos($buffer, '__HALT_COMPI' . 'LER();')) {
                    $buffer .= fread($fp, 5);
                    fclose($fp);
                    $pos += 18;
                    $pos += self::_endOfStubLength(substr($buffer, $pos));
                    return self::_mapPhar($file, $pos, $alias);
                }
            }
            fclose($fp);
        }
    }

    /**
     * Map a full real file path to an alias used to refer to the .phar
     *
     * This function can only be called from the initialization of the .phar itself.
     * Any attempt to call from outside the .phar or to re-alias the .phar will fail
     * as a security measure.
     * @param string $alias
     * @param int $dataoffset the value of __COMPILER_HALT_OFFSET__
     */
    public static final function mapPhar($alias = NULL, $dataoffset = NULL)
    {
        try {
            $trace = debug_backtrace();
            $file = $trace[0]['file'];
            // this ensures that this is safe
            if (!in_array($file, get_included_files())) {
                die('SECURITY ERROR: PHP_Archive::mapPhar can only be called from within ' .
                    'the phar that initiates it');
            }
            $file = realpath($file);
            if (!isset($dataoffset)) {
                $dataoffset = constant('__COMPILER_HALT_OFFSET'.'__');
                $fp = fopen($file, 'rb');
                fseek($fp, $dataoffset, SEEK_SET);
                $dataoffset = $dataoffset + self::_endOfStubLength(fread($fp, 5));
                fclose($fp);
            }

            self::_mapPhar($file, $dataoffset);
        } catch (Exception $e) {
            die($e->getMessage());
        }
    }

    /**
     * Sub-function, allows recovery from errors
     *
     * @param unknown_type $file
     * @param unknown_type $dataoffset
     */
    private static function _mapPhar($file, $dataoffset, $alias = NULL)
    {
        $file = realpath($file);
        if (isset(self::$_manifest[$file])) {
            return;
        }
        if (!is_array(self::$_pharMapping)) {
            self::$_pharMapping = array();
        }
        $fp = fopen($file, 'rb');
        // seek to __HALT_COMPILER_OFFSET__
        fseek($fp, $dataoffset);
        $manifest_length = unpack('Vlen', fread($fp, 4));
        $manifest = '';
        $last = '1';
        while (strlen($last) && strlen($manifest) < $manifest_length['len']) {
            $read = 8192;
            if ($manifest_length['len'] - strlen($manifest) < 8192) {
                $read = $manifest_length['len'] - strlen($manifest);
            }
            $last = fread($fp, $read);
            $manifest .= $last;
        }
        if (strlen($manifest) < $manifest_length['len']) {
            throw new Exception('ERROR: manifest length read was "' .
                strlen($manifest) .'" should be "' .
                $manifest_length['len'] . '"');
        }
        $info = self::_unserializeManifest($manifest);
        if ($info['alias']) {
            $alias = $info['alias'];
            $explicit = true;
        } else {
            if (!isset($alias)) {
                $alias = $file;
            }
            $explicit = false;
        }
        self::$_manifest[$file] = $info['manifest'];
        $compressed = $info['compressed'];
        self::$_fileStart[$file] = ftell($fp);
        fclose($fp);
        if ($compressed & 0x00001000) {
            if (!function_exists('gzinflate')) {
                throw new Exception('Error: zlib extension is not enabled - gzinflate() function needed' .
                    ' for compressed .phars');
            }
        }
        if ($compressed & 0x00002000) {
            if (!function_exists('bzdecompress')) {
                throw new Exception('Error: bzip2 extension is not enabled - bzdecompress() function needed' .
                    ' for compressed .phars');
            }
        }
        if (isset(self::$_pharMapping[$alias])) {
            throw new Exception('ERROR: PHP_Archive::mapPhar has already been called for alias "' .
                $alias . '" cannot re-alias to "' . $file . '"');
        }
        self::$_pharMapping[$alias] = array($file, $compressed, $dataoffset, $explicit,
            $info['metadata']);
        self::$_pharFiles[$file] = $alias;
    }

    /**
     * extract the manifest into an internal array
     *
     * @param string $manifest
     * @return false|array
     */
    private static function _unserializeManifest($manifest)
    {
        // retrieve the number of files in the manifest
        $info = unpack('V', substr($manifest, 0, 4));
        $apiver = substr($manifest, 4, 2);
        $apiver = bin2hex($apiver);
        $apiver_dots = hexdec($apiver[0]) . '.' . hexdec($apiver[1]) . '.' . hexdec($apiver[2]);
        $majorcompat = hexdec($apiver[0]);
        $calcapi = explode('.', self::APIVersion());
        if ($calcapi[0] != $majorcompat) {
            throw new Exception('Phar is incompatible API version ' . $apiver_dots . ', but ' .
                'PHP_Archive is API version '.self::APIVersion());
        }
        if ($calcapi[0] === '0') {
            if (self::APIVersion() != $apiver_dots) {
                throw new Exception('Phar is API version ' . $apiver_dots .
                    ', but PHP_Archive is API version '.self::APIVersion(), E_USER_ERROR);
            }
        }
        $flags = unpack('V', substr($manifest, 6, 4));
        $ret = array('compressed' => $flags[1] & 0x00003000);
        // signature is not verified by default in PHP_Archive, phar is better
        $ret['hassignature'] = $flags & 0x00010000;
        $aliaslen = unpack('V', substr($manifest, 10, 4));
        if ($aliaslen) {
            $ret['alias'] = substr($manifest, 14, $aliaslen[1]);
        } else {
            $ret['alias'] = false;
        }
        $manifest = substr($manifest, 14 + $aliaslen[1]);
        $metadatalen = unpack('V', substr($manifest, 0, 4));
        if ($metadatalen[1]) {
            $ret['metadata'] = unserialize(substr($manifest, 4, $metadatalen[1]));
            $manifest = substr($manifest, 4 + $metadatalen[1]);
        } else {
            $ret['metadata'] = null;
            $manifest = substr($manifest, 4);
        }
        $offset = 0;
        $start = 0;
        for ($i = 0; $i < $info[1]; $i++) {
            // length of the file name
            $len = unpack('V', substr($manifest, $start, 4));
            $start += 4;
            // file name
            $savepath = substr($manifest, $start, $len[1]);
            $start += $len[1];
            // retrieve manifest data:
            // 0 = uncompressed file size
            // 1 = timestamp of when file was added to phar
            // 2 = compressed filesize
            // 3 = crc32
            // 4 = flags
            // 5 = metadata length
            $ret['manifest'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($manifest, $start, 24)));
            $ret['manifest'][$savepath][3] = sprintf('%u', $ret['manifest'][$savepath][3]
                & 0xffffffff);
            if ($ret['manifest'][$savepath][5]) {
                $ret['manifest'][$savepath][6] = unserialize(substr($manifest, $start + 24,
                    $ret['manifest'][$savepath][5]));
            } else {
                $ret['manifest'][$savepath][6] = null;
            }
            $ret['manifest'][$savepath][7] = $offset;
            $offset += $ret['manifest'][$savepath][2];
            $start += 24 + $ret['manifest'][$savepath][5];
        }
        return $ret;
    }

    /**
     * @param string
     */
    private static function processFile($path)
    {
        if ($path == '.') {
            return '';
        }
        $std = str_replace("\\", "/", $path);
        while ($std != ($std = preg_replace("/[^\/:?]+\/\.\.\//", "", $std))) ;
        $std = str_replace("/./", "", $std);
        if (strlen($std) > 1 && $std[0] == '/') {
            $std = substr($std, 1);
        }
        if (strncmp($std, "./", 2) == 0) {
            return substr($std, 2);
        } else {
            return $std;
        }
    }

    /**
     * Seek in the master archive to a matching file or directory
     * @param string
     */
    protected function selectFile($path, $allowdirs = true)
    {
        $std = self::processFile($path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            if ($path[strlen($path)-1] == '/') {
                // directory
                if (!$allowdirs) {
                    return 'Error: "' . $path . '" is a directory in phar "' . $this->_basename . '"';
                }
                $this->_setCurrentFile($path, true);
            } else {
                $this->_setCurrentFile($path);
            }
            return true;
        }
        if (!$allowdirs) {
            return 'Error: "' . $path . '" is not a file in phar "' . $this->_basename . '"';
        }
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if (empty($std) ||
                  //$std is a directory
                  strncmp($std.'/', $path, strlen($std)+1) == 0) {
                $this->currentFilename = $this->internalFileLength = $this->currentStat = null;
                return true;
            }
        }
        return 'Error: "' . $path . '" not found in phar "' . $this->_basename . '"';
    }

    private function _setCurrentFile($path, $dir = false)
    {
        if ($dir) {
            $this->currentStat = array(
                2 => 040777, // directory mode, readable by all, writeable by none
                4 => 0, // uid
                5 => 0, // gid
                7 => 0, // size
                9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
                );
            $this->internalFileLength = 0;
            $this->isDir = true;
        } else {
            $this->currentStat = array(
                2 => 0100444, // file mode, readable by all, writeable by none
                4 => 0, // uid
                5 => 0, // gid
                7 => self::$_manifest[$this->_archiveName][$path][0], // size
                9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
                );
            $this->internalFileLength = self::$_manifest[$this->_archiveName][$path][2];
            $this->isDir = false;
        }
        $this->currentFilename = $path;
        // seek to offset of file header within the .phar
        if (is_resource(@$this->fp)) {
            fseek($this->fp, self::$_fileStart[$this->_archiveName] + self::$_manifest[$this->_archiveName][$path][7]);
        }
    }

    private static function _fileExists($archive, $path)
    {
        return isset(self::$_manifest[$archive]) &&
            isset(self::$_manifest[$archive][$path]);
    }

    private static function _filesize($archive, $path)
    {
        return self::$_manifest[$archive][$path][0];
    }

    /**
     * Seek to a file within the master archive, and extract its contents
     * @param string
     * @return array|string an array containing an error message string is returned
     *                      upon error, otherwise the file contents are returned
     */
    public function extractFile($path)
    {
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            return array('Error: cannot open phar "' . $this->_archiveName . '"');
        }
        if (($e = $this->selectFile($path, false)) === true) {
            $data = '';
            $count = $this->internalFileLength;
            while ($count) {
                if ($count < 8192) {
                    $data .= @fread($this->fp, $count);
                    $count = 0;
                } else {
                    $count -= 8192;
                    $data .= @fread($this->fp, 8192);
                }
            }
            @fclose($this->fp);
            if (self::$_manifest[$this->_archiveName][$path][4] & self::GZ) {
                $data = gzinflate($data);
            } elseif (self::$_manifest[$this->_archiveName][$path][4] & self::BZ2) {
                $data = bzdecompress($data);
            }
            if (!isset(self::$_manifest[$this->_archiveName][$path]['ok'])) {
                if (strlen($data) != $this->currentStat[7]) {
                    return array("Not valid internal .phar file (size error {$size} != " .
                        $this->currentStat[7] . ")");
                }
                if (self::$_manifest[$this->_archiveName][$path][3] != sprintf("%u", crc32($data) & 0xffffffff)) {
                    return array("Not valid internal .phar file (checksum error)");
                }
                self::$_manifest[$this->_archiveName][$path]['ok'] = true;
            }
            return $data;
        } else {
            @fclose($this->fp);
            return array($e);
        }
    }

    /**
     * Parse urls like phar:///fullpath/to/my.phar/file.txt
     *
     * @param string $file
     * @return false|array
     */
    static protected function parseUrl($file)
    {
        if (substr($file, 0, 7) != 'phar://') {
            return false;
        }
        $file = substr($file, 7);

        $ret = array('scheme' => 'phar');
        $pos_p = strpos($file, '.phar.php');
        $pos_z = strpos($file, '.phar.gz');
        $pos_b = strpos($file, '.phar.bz2');
        if ($pos_p) {
            if ($pos_z) {
                return false;
            }
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar.php'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_z) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.gz'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_b) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.bz2'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif (($pos_p = strpos($file, ".phar")) !== false) {
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } else {
            return false;
        }
        if (!$ret['path']) {
            $ret['path'] = '/';
        }
        return $ret;
    }

    /**
     * Locate the .phar archive in the include_path and detect the file to open within
     * the archive.
     *
     * Possible parameters are phar://pharname.phar/filename_within_phar.ext
     * @param string a file within the archive
     * @return string the filename within the .phar to retrieve
     */
    public function initializeStream($file)
    {
        $file = self::processFile($file);
        $info = @parse_url($file);
        if (!$info) {
            $info = self::parseUrl($file);
        }
        if (!$info) {
            return false;
        }
        if (!isset($info['host'])) {
            // malformed internal file
            return false;
        }
        if (!isset(self::$_pharFiles[$info['host']]) &&
              !isset(self::$_pharMapping[$info['host']])) {
            try {
                self::loadPhar($info['host']);
                // use alias from here out
                $info['host'] = self::$_pharFiles[$info['host']];
            } catch (Exception $e) {
                return false;
            }
        }
        if (!isset($info['path'])) {
            return false;
        } elseif (strlen($info['path']) > 1) {
            $info['path'] = substr($info['path'], 1);
        }
        if (isset(self::$_pharMapping[$info['host']])) {
            $this->_basename = $info['host'];
            $this->_archiveName = self::$_pharMapping[$info['host']][0];
            $this->_compressed = self::$_pharMapping[$info['host']][1];
        } elseif (isset(self::$_pharFiles[$info['host']])) {
            $this->_archiveName = $info['host'];
            $this->_basename = self::$_pharFiles[$info['host']];
            $this->_compressed = self::$_pharMapping[$this->_basename][1];
        }
        $file = $info['path'];
        return $file;
    }

    /**
     * Open the requested file - PHP streams API
     *
     * @param string $file String provided by the Stream wrapper
     * @access private
     */
    public function stream_open($file)
    {
        return $this->_streamOpen($file);
    }

    /**
     * @param string filename to opne, or directory name
     * @param bool if true, a directory will be matched, otherwise only files
     *             will be matched
     * @uses trigger_error()
     * @return bool success of opening
     * @access private
     */
    private function _streamOpen($file, $searchForDir = false)
    {
        $path = $this->initializeStream($file);
        if (!$path) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
        }
        if (is_array($this->file = $this->extractFile($path))) {
            trigger_error($this->file[0], E_USER_ERROR);
            return false;
        }
        if ($path != $this->currentFilename) {
            if (!$searchForDir) {
                trigger_error("Cannot open '$file', is a directory", E_USER_ERROR);
                return false;
            } else {
                $this->file = '';
                return true;
            }
        }

        if (!is_null($this->file) && $this->file !== false) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Read the data - PHP streams API
     *
     * @param int
     * @access private
     */
    public function stream_read($count)
    {
        $ret = substr($this->file, $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }

    /**
     * Whether we've hit the end of the file - PHP streams API
     * @access private
     */
    function stream_eof()
    {
        return $this->position >= $this->currentStat[7];
    }

    /**
     * For seeking the stream - PHP streams API
     * @param int
     * @param SEEK_SET|SEEK_CUR|SEEK_END
     * @access private
     */
    public function stream_seek($pos, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                if ($pos < 0) {
                    return false;
                }
                $this->position = $pos;
                break;
            case SEEK_CUR:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position += $pos;
                break;
            case SEEK_END:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position = $pos + $this->currentStat[7];
                break;
            default:
                return false;
        }
        return true;
    }

    /**
     * The current position in the stream - PHP streams API
     * @access private
     */
    public function stream_tell()
    {
        return $this->position;
    }

    /**
     * The result of an fstat call, returns mod time from creation, and file size -
     * PHP streams API
     * @uses _stream_stat()
     * @access private
     */
    public function stream_stat()
    {
        return $this->_stream_stat();
    }

    /**
     * Retrieve statistics on a file or directory within the .phar
     * @param string file/directory to stat
     * @access private
     */
    public function _stream_stat($file = null)
    {
        $std = $file ? self::processFile($file) : $this->currentFilename;
        if ($file) {
            if (isset(self::$_manifest[$this->_archiveName][$file])) {
                $this->_setCurrentFile($file);
                $isdir = false;
            } else {
                do {
                    $isdir = false;
                    if ($file == '/') {
                        break;
                    }
                    foreach (self::$_manifest[$this->_archiveName] as $path => $info) {
                        if (strpos($path, $file) === 0) {
                            if (strlen($path) > strlen($file) &&
                                  $path[strlen($file)] == '/') {
                                break 2;
                            }
                        }
                    }
                    // no files exist and no directories match this string
                    return false;
                } while (false);
                $isdir = true;
            }
        } else {
            $isdir = false; // open streams must be files
        }
        $mode = $isdir ? 0040444 : 0100444;
        // 040000 = dir, 010000 = file
        // everything is readable, nothing is writeable
        return array(
           0, 0, $mode, 0, 0, 0, 0, 0, 0, 0, 0, 0, // non-associative indices
           'dev' => 0, 'ino' => 0,
           'mode' => $mode,
           'nlink' => 0, 'uid' => 0, 'gid' => 0, 'rdev' => 0, 'blksize' => 0, 'blocks' => 0,
           'size' => $this->currentStat[7],
           'atime' => $this->currentStat[9],
           'mtime' => $this->currentStat[9],
           'ctime' => $this->currentStat[9],
           );
    }

    /**
     * Stat a closed file or directory - PHP streams API
     * @param string
     * @param int
     * @access private
     */
    public function url_stat($url, $flags)
    {
        $path = $this->initializeStream($url);
        return $this->_stream_stat($path);
    }

    /**
     * Open a directory in the .phar for reading - PHP streams API
     * @param string directory name
     * @access private
     */
    public function dir_opendir($path)
    {
        $info = @parse_url($path);
        if (!$info) {
            $info = self::parseUrl($path);
            if (!$info) {
                trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                    E_USER_ERROR);
                return false;
            }
        }
        $path = !empty($info['path']) ?
            $info['host'] . $info['path'] : $info['host'] . '/';
        $path = $this->initializeStream('phar://' . $path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                E_USER_ERROR);
            return false;
        }
        if ($path == false) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
            return false;
        }
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            trigger_error('Error: cannot open phar "' . $this->_archiveName . '"');
            return false;
        }
        $this->_dirFiles = array();
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if ($path == '/') {
                if (strpos($file, '/')) {
                    $a = explode('/', $file);
                    $this->_dirFiles[array_shift($a)] = true;
                } else {
                    $this->_dirFiles[$file] = true;
                }
            } elseif (strpos($file, $path) === 0) {
                $fname = substr($file, strlen($path) + 1);
                if ($fname == '/' || $fname[strlen($fname)-1] == '/') {
                    continue; // empty directory
                }
                if (strpos($fname, '/')) {
                    // this is a directory
                    $a = explode('/', $fname);
                    $this->_dirFiles[array_shift($a)] = true;
                } elseif ($file[strlen($path)] == '/') {
                    // this is a file
                    $this->_dirFiles[$fname] = true;
                }
            }
        }
        @fclose($this->fp);
        if (!count($this->_dirFiles)) {
            return false;
        }
        @uksort($this->_dirFiles, 'strnatcmp');
        return true;
    }

    /**
     * Read the next directory entry - PHP streams API
     * @access private
     */
    public function dir_readdir()
    {
        $ret = key($this->_dirFiles);
        @next($this->_dirFiles);
        if (!$ret) {
            return false;
        }
        return $ret;
    }

    /**
     * Close a directory handle opened with opendir() - PHP streams API
     * @access private
     */
    public function dir_closedir()
    {
        $this->_dirFiles = array();
        return true;
    }

    /**
     * Rewind to the first directory entry - PHP streams API
     * @access private
     */
    public function dir_rewinddir()
    {
        @reset($this->_dirFiles);
        return true;
    }

    /**
     * API version of this class
     * @return string
     */
    public static final function APIVersion()
    {
        return '1.1.0';
    }

    /**
     * Retrieve Phar-specific metadata for a Phar archive
     *
     * @param string $phar full path to Phar archive, or alias
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getPharMetadata($phar)
    {
        if (isset(self::$_pharFiles[$phar])) {
            $phar = self::$_pharFiles[$phar];
        }
        if (!isset(self::$_pharMapping[$phar])) {
            throw new Exception('Unknown Phar archive: "' . $phar . '"');
        }
        return self::$_pharMapping[$phar][4];
    }

    /**
     * Retrieve File-specific metadata for a Phar archive file
     *
     * @param string $phar full path to Phar archive, or alias
     * @param string $file relative path to file within Phar archive
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getFileMetadata($phar, $file)
    {
        if (!isset(self::$_pharFiles[$phar])) {
            if (!isset(self::$_pharMapping[$phar])) {
                throw new Exception('Unknown Phar archive: "' . $phar . '"');
            }
            $phar = self::$_pharMapping[$phar][0];
        }
        if (!isset(self::$_manifest[$phar])) {
            throw new Exception('Unknown Phar: "' . $phar . '"');
        }
        $file = self::processFile($file);
        if (!isset(self::$_manifest[$phar][$file])) {
            throw new Exception('Unknown file "' . $file . '" within Phar "'. $phar . '"');
        }
        return self::$_manifest[$phar][$file][6];
    }

    /**
     * @return list of supported signature algorithmns.
     */
    public static function getSupportedSignatures()
    {
        $ret = array('MD5', 'SHA-1');
        if (extension_loaded('hash')) {
            $ret[] = 'SHA-256';
            $ret[] = 'SHA-512';
        }
        if (extension_loaded('openssl')) {
            $ret[] = 'OpenSSL';
        }
        return $ret;
    }
}
?>
<?php
}
if (!in_array('phar', stream_get_wrappers())) {
	stream_wrapper_register('phar', 'PHP_Archive');
}
if (!class_exists('Phar',0)) {
	include 'phar://'.__FILE__.'/phar.inc';
}
?><?php

/** @file phar.php
 * @ingroup Phar
 * @brief class CLICommand
 * @author  Marcus Boerger
 * @date    2007 - 2008
 *
 * Phar Command
 */

if (!extension_loaded('phar'))
{
	if (!class_exists('PHP_Archive', 0)) {
		echo "Neither Extension Phar nor class PHP_Archive are available.\n";
		exit(1);
	}
	if (!in_array('phar', stream_get_wrappers())) {
		stream_wrapper_register('phar', 'PHP_Archive');
	}
	if (!class_exists('Phar',0)) {
		require 'phar://'.__FILE__.'/phar.inc';
	}
}

foreach(array("SPL", "Reflection") as $ext)
{
	if (!extension_loaded($ext)) {
		echo "$argv[0] requires PHP extension $ext.\n";
		exit(1);
	}
}

function command_include($file)
{
	$file = 'phar://' . __FILE__ . '/' . $file;
	if (file_exists($file)) {
		include($file);
	}
}

function command_autoload($classname)
{
	command_include(strtolower($classname) . '.inc');
}

Phar::mapPhar();

spl_autoload_register('command_autoload');

new PharCommand($argc, $argv);

__HALT_COMPILER(); ?>
6            pharcommand       clicommand.incü!  {¯eV%
  Çší¶         invertedregexiterator.inc»  {¯eVÏ   Ñar¶         pharcommand.incRœ  {¯eVı#  ?Œgp¶         directorytreeiterator.incè  {¯eVN  1s»ã¶         directorygraphiterator.incÑ  {¯eVi  ƒò@Ä¶         phar.inc  {¯eV+  CbcD¶      µksÚHò3üŠ1Å­¤°±·j÷L`/—»­Úªd/åd?Š’Åt7#a»²şï×İóĞ	ìÍí¥Ê fzú=ıR^ÿ´Ûìºİ‹W¯Øßâ$å,J“(ßnÃl5J²¨Ë`=ÉÖ"/wìÃ&´p'd(%{ûî—·
¶Â²Øä‚±÷¡ˆJÉşs±æêÔ*,8ƒW——?°!~ıë¸…ˆY…åBós„.coîd!Â¨`w¡óLæÈ¹BÀ’í.å[a‘äÙs\í¹ ÆÆ£K"Üñ¾v;;‘<*øŠõC±&‡+ûúJ´]I6e¡á£4 î»Ú^·—Y„Ò°åÅ-D>ñ0P`Š|Ğí —~±Iäp†Û€Æ°ê,ïõòŞYÖÌJÆ77k^h±¥Oû©Ù³oÄú,Y@€Lb¦Øc¯ÙUÀ©‚çBäÂïıš[{­“=Ï,ÚğèëE¶æ—‹'¶áéîsÖ#ÊOŒ§’#Ö³DJ^øÓs’d>^,æ(3o´ü-û’å÷™¥êiJãÅ“÷"â
gßœ×
„ób„náNŸ îà@Å]eTf¦é²”\,ÑÔ¾2=ØilB– ±zÜpu`!oZ¼ßàİöÏÏğµòÍ†5Õ~ŞO ;›N™7ôÌ6íƒÃ¥<«Àºbß}Çjò¢,ó
X$°h:¸nµ¦¶'zIk³i·C#¾×¢L‰7œ9Û…"Üò‚0)ª„å±cdıôœ‰ñŸkæNİ@$¨|¦Ş…ĞA”ÊûI7`ªdÀôµTÒ"ïju"­.êJôÕ¨ëÉCa`F®çÅR„ë²İ	~Qû´MŞÛt_’Ü«<V¹J‹•„ÉÿS&‚ô–SÛ­*1_ñ8,S°·“Ôõ ùçi¥Áœ±v£;æ*ùÍ{tÁ|áxıùù¢ÎA·bCk÷ í‡ğ‡JF#ÿ“"”áãü!Ú¸Æc¡dêÂÎÀ§³Øõ 'QMD0-ràDZÕf^7h,˜Ø5š2fïÜ‡¡ºâHÔVG7Bh‚A›ºí¦Ö•>ÿ¡Z¥¥ëÿˆÑI,S"f|–ÃOÕı­\ëtïD’±ÿñÓ?şy{XpëÈqâ\@şP0¬8fMI¨ÈøU!ı
Ş ·x_êLíñ¸«"¤<aÃ[LZ%Vs<iÀŒ=/J‘½$;6Qª\3hò£vù]´'UroU5T>Ë»Ÿá§ô«2‘ª>ªÂNğ8y°%š,ï¤QSX,}¿3~Ïnyœr"ğ‘øK±ğÒ¾«°«‚ËŞa1œcï9¼P»t‘·Z›äø%¸`øá,ƒ[5`—ÀgJ	İ ÔWÁ¢Ä#„ª«z¿	dæ_?=7"üùØÎ>jY2lDáË[zøNb)ø.ÁUj€…É@A¬5AèM(•Ğ>Ñq
·jçtØ­K:v±êMÖ®@æÈ2^¼B‰U ÜÜ€¯.Ñn‰ğÊ‹*ï:r{İ²»Í¥´óh4¶ ·nèøÜ~¢Ö”TT0<ˆ½ğ‰)8DœšşÏàè:\àå<JÙ€Ğò.ÏSk¢?¿ğÇ:ma„y>ˆ¡ÇĞ¡‹ø°O¨Ø™Ê×m]Ä§ğ"¶-%ô¡œ…ÚÊ‘íº§û€åá«nv¯¶›˜glL©~è¢]˜áx °´Ë¥ï]<Aºy0×Ä	‹§d©mztQƒ#üQeÍf|ıõ·wïN„VW ´ÜY’-uJ  z^ºb¼{
f•6›~°å/%7mdH–gÛ	¯ı;O2¿‡1¨w’€ö<Ç•÷œ¼«D¶Cä œîÂbãëüeºíx:’ÍØï¿³3œå,!Ë8„ò×©Ç­j¸…rŒK,-»ÑÂ*ç’TA¸ZÅŠ_ TL532ìH‚éîã.ıö~ÉâÜ·	™vû1e²[÷ŠK;ÏKªEãÑ&gL4Û:*¹*•@ão¤9j7€ê1AHYYsåÚîkıx,Òó3R5EQ>qpVãæ%FùñªI1Àj8¥*°+ñã­¾PCÓ¬8ábúøáÊï§cš–Ø‹ÔÓ*xXøÃ –Ù9»‚¿ïáïÇh¯5Úôêqëg@€O§´ˆy°/±#ñë4zŸ 0¥V…Aé-2QÀuÍ8¶§	@7°ÇQjÂ}.V÷"„âëdşäÎ8 –äÛğÁÿá¯lH{ß_Æ²‹¶M²d[nøğZ;¶\k@·ÁÃwN™§°«šq‚‡a5ÖËÒ_R$a
;¦­¢Š¢àÛ0ÉV\XH§Ğëë~@8'¥$«Î1Ì>gt<ËÉJKğ
UpJ¨yrlTiµˆ<èfÕ(¬	l÷(r˜Bù K©ãj-5\ØÉÜ¦Âåf·Ü\Å
År¤³0Ş¸$+¹ÓØ©Ì(®Gİ44ÚÍ”n F£‘Ù&Œ È•3ÿª]Ñš¨!$Ü	§SSfN	zÕTæ’»ª~ĞBc±º0w±`v¥€}0±Rà6£Ş¢¼Ìš;V)]/'õV§L&Ëw™ŒšÛıĞi¼Qğ4°r¬Èêêx¾nÓ×µÒ­”X¯ëZ»¾•¿Óz¾B5‚ááKêáBï/Ãş×T>IXÖÀ4eÈè5éÿºÒ£·qErÜ»á«æº’Å)Kãn5Ëºùœ¤˜œúø¿vx‰!ğwOW¥f#.cäo‰Ëº[ñP·Nç2yaöº¦3¬cUK–3›‚&°‰„ï¹ì#¯=Õ!+Ğ”ÕX¡)«MSÔ›ûMm¦,ÕÄÑJúj°k}1Ô:Æ’që°ñ=8+6ĞØ`\{[3:˜ VÑ4CìÌ–Ê¶H#˜Ú¬,8˜/yšßsayÄWšY½™¨JWyË¨ØŠºËÚ<õZhÀ¢0Ã"ªf·†¸îF±¨¢[í…ŸQÊ¬>¤ÕEcğ¤
ÖÏY_/ÙkÍÒŒÍsr,¹ ·XTğú"sQ{ã¤x9êg.°ê#Ğûdm8«¢‚ÕğÓ&=3¢¸1¼ÈÂæBZ9Ú¡Ùñ¹~5õGy¼Ã ôÂH€@/¤®ÖèGx”"ëjĞ,â`5ĞqÌªSÎaÌÔÎd¦-• )ùœØ|R­<µ9²¥-úv®/!Ñ™°Ê^'âûÉai›S¸q½I½öæ²"_iã¨^Rµò¡ğ:…V!JLşßTTguÄôDÖ3p½
!/)ïuø©×øï0ğ±p&ixWıWikú£© †®ıªÛ4 ×tGµk-üÔ’?Íºÿ…Ak1…Ï™_1ŞT¨n½(Z´xóP(ı1;»d™LŠ şw“íQPs	Ì›ï½7›¶i¦ã1~Vö@hİ/±PÉTÓÑ
±Ïë`Z±®f[ün4wƒ=[ªĞt¸ëÑŸŒîz´ÛÒQÏˆ_šM¸õÄ5ıI¥ÂôfE1Ç·ü-Ò<Kÿvxï7íû>(ƒÉ§M¬wø>)º'G!…\îN ºbLÙáàF].µ1ÔÊp*Û«*:#9ğ:Oê¼u†3Àf}í=kwÛ6²Ÿ_dİ¥ÔÈò£›6k7NİÔmsN>qÚŞm’u)	’¹¦H.I9vÛü÷; HP¢ìt·÷œ›sZKä`0Ìƒôåãì<»sgûÓOïˆOÅWÓ(–";óq:Ÿ‡Éd%cz%³<]dâŞÑƒQÉ©ÇaQˆ'Ï>axz.Êó4â9 YâëTæ3É­&a)üÛÛÙùBláŸ‡ğ_!bQaÙ¾³½-~ûí7Õ¾U/…¼*e2qzUäÛPÔâ¯Ï£Ba:‡—±,Dy.ù3ŒL¤Sú©Á©ÁCñ´ï£8#)…œˆiÎõkMåö8MŠ4–Ø,JDšOd.ÊTä²]JÁËñ¢dübºHÆe­†šº6æ
fŠêÁtÍ³XÎeR†ˆfÇ/e^ ˜Øî[;ñó·;ŠıÙbGcC401:›ÉòìôdïÎÆ’—½Íxw 6Ã|v%Óş@¹LYä‰(Êü,—™Ë^ €ŠwÅ}±ÿışû{ÿàÎÆ"àÃ‡ù``ş7`´OâH|'KA?û*ópâLc_ôï8†ÙI¼{ñú½Œ/¥BŠ_UƒÂw jRğà@\øá·ïløhW|Š÷nÈ,õ‰†O~Ö()ëPÏ ³¢b	<Z \ôˆşGŠSÑ‚ĞEI!BP	­0F[ê7ìzÏ‘£?Ñİ@<O™½ÍyyIb)} 5Å‡QdrMqLh¯@İŞ§ù…HgFÉE’¾Oó[™ĞcúU‡j6ˆxDçáuna Z6hDÏ‚0Â"ğÓË0¦§/~xöL=‚ÙeÀ/	ò4<O/£	š	ADÎ¥˜‚2şâ‡"èš`´„€äºS÷£0™Aïâû°8ßÂ/dÌ“À§¼¤ÎÁ–œG`Ázr8Š¿Üİ^ùö(J¶Ácô‡4+çĞ\iğO¡ÿÍC˜¨,d<oƒ¿Ü}!D´‰|O}alá¸”(w0µÎJ;·„.ãYG^ÏR,X·,—™C|–Gåù|¨Q ­r\Ö{ÜvhTˆèEŠ²®Q¨vA’&2X Ö9e€#ø4G9ºÜ£İ¤"‹™Ú·˜!Û™Ê”w›w‚^¼@)u¢ï–‰Ş|Q€f&ãxRyòıÑ+ø“S#&Qô¦Ğ€„4šÂœ^÷›¶i´«™(ò8c§¬çÊ]m°vz?og‘šİ.Ï%8ÓÉ¡8¥&:R Aï 3Á|ò€Ñ<ÿæA0Šóp—¿Ÿ~´Øóµ›Ë™¼êD+AÚŒ
ÁûÌ1pJ^±B{%Ù¢$öÓ.noM¢dÂT,FÅ8H•=tfj`õ·÷
òVïu§Ñ%zïy1	AÏ Â)'è9ŠÅH‹*‰NJ.%ãàäÅ^9ÍoÏœÅö9üê†Üw
öí=ÈÒ¶^!óŒı¯ €)%@W‹²vRâ4„³5z(¥cŠ‘I'ßŸœ)»Î‘ ñ£ñE. (·H@l8Eø¤1_Á0Øõ0ë Yoƒ]ø C±'0¥C·(pZPĞï)0r)u®$ÈDµà°}')—¤¥y=§ Ñïa,ŒÖĞ€Z„‡ ©›9¨)`F0‰‹T„‹tı /†`\9+gQ.F ÃR¯J,nB<W êeãWöjb0>	Íû<Ì2U'˜Ğ¤¶(Âüz( Ói”ËJ‹FZ D‘Y¡áÒŒEÚBHÍ²p|ÎxéB€³#“b‘KkA…š˜“jm•(ÚåÉè$…È62åììpÄÉFTsõ1íá«•68rEnÎ!ãºŒ,./d7S p8jˆï¢KÔ	øN¼ÌdrzúLÑ,Á¥e‚ x‡ÿƒHôhE†DŸ‘OzÁ¯q4
ú}q©˜¾éİí†àÓì×à…+"øîg0yv8r°²m”aë¶¶ÚÉıº×…:{ÇÔ}=ì­EŞÈÃæ­‰¾MôÔgáeÅ ‰R¾¿ªyºÈ²4í?¾‡°<EK
^GŸ&ĞGw½µ÷àsã»ñ³Šç@I=Ûz°»g ğ³ fšôêyx7JÎTWú¬@*â57I!ËÍ–ëà]ßDJ†ãó^m`|6Qâ0îÂXM!ÃM¿àíÒ™„sgÀ’•iœ¾—yñâtĞ'š½fœU¶!µZV!™±¦s<i	Zà3cêqv³G }“\ş{¡™%ˆ,µVqØ¸/î>z$¦`Ü™°Mk‚ëğq^sªêä÷ß…Á`˜Dü¡ÖÄ ÿ ñâM qàŒ·ÌBŸÚuZ¿Ãa½ı„Õ
ş”WÍøBğ½†‡
V–YzeMÙ
HBpø*‘ræ¸-gr^ã¡}üÍÉˆ({BK=ƒÖ¬ÊçÑæÑÕ¸‚@‡%Ò¤Iº'–ÌÊU ^BàşƒŞ€*šZÖØJ— O
ÀâcÏŒq QKÃP6Ø|eÒÓà}ñè‘nÛi1„)ğ/lHój6t„òú­v æ³"šI^lD å•"4ˆØĞéÑ²ãCÕ?“âiD8ŞH=®«“i4[äe‚_Í°)üq±O={“–£œÀ_.GöšRÌ¶™l²²‡Dà€zRÓ‰ŠMïp¶pmº­¿ÂMüõ¯â.R|&¯ ”+–*	@¼<À’D|†fC?=}hË5¥ÈñÅlyÂx—Çe!Èç#Nbˆ7{'G¯¿?;=>9zuôúå+ ÷ìøÅo|¬l=4ÁÙF¢Ì)˜)Â†¦"ÄÖI©mÖ‹CñÍÓWÇO ¿T]ÃS
Æyº±£Š3Î^‡£X®@“`(/ó¾±1Ê/øómÙâ"le`5ç~![ÿ†ğmš:A÷ŞáöD^n'‹8ş}–ËLG'OÅœò~9¨!±š÷´&óÓPjì´ì÷û.e­iÃ¼Öş>Ïh,{÷N^™ Û"o_X8÷…Â1|›Üë+Ê8µDá¼¨û—c¿è¶°t„U®aÏ˜”pb\Tá+‹;¿Ô+ÔW…±ë T+kWØ§Aiæß¸}	Ê©%¡@,Çç²°•F¡„ènvF¯{÷ÿÄoÄÛòİıŞ›âßá§oŞÂ¿íw@œú¤H|;Äåæ 8‰}ÁÿUUĞ/ÈºdõêÍî;İ5õ­£€ès”°c!ñ(|]Âµ9ĞˆÖ¼v€,ÿù $ºIÕ]×ù§y¾ÈJAëpŒËË”WŒBÀÃà<s§ĞUÄ¨ ¨“Èí¯+ôÜ¬ÂíŒbs^€­­Íiqş§„U°œìÃ²:‘9í¥Pö–Â*ŠÂf¯²…Y’àBüŒ—(¨äÓ²ù}/G‘2Íß)áà 1j5î7ªãÆ¶B=`¯²v”€CÚ& ³¥-Ì¶ãO5¤0öÜ¿órïˆÆì
Qb ƒŸWÌhsôjRüü÷¶3K3^5FÅaMğË·*vâiSâc‹Å½š.%ĞÏÃK•ª©$3"É›Ñ4RÕ\£Æª¯°7
T[#ÜHjx’übCÁNˆDµvxÅıšà1Åœ¿Û¢±j¨¦j-@Ìˆ’*‘”fm{$xºéØ@ò9ï}·ŠnŠ_¬C¯j±,ªa"œŞ¨ø¢šƒÁ`Øc’F¸£à#à‘\ÌW™"¬M}B¬m¸c$?õ¶šAWüM=+<E¢*CN¸µ(jt$¢bLnúøj,9û¿)}jR½‡Õw,©+œ«·}èÂÈM¹u±ÌsÌÎd¯îY
±¾,ò¸MháıV]X²ÿä\Â’·´–½h¼¯^Ê²*D¥Ú¿…ÈeŠë\ÂC«Q•®°_íÓß/1å|È2e³*ÀAoHÆ`›D­Åƒy†Æ–‰nŒ­Z‰Â«ÌÌ×›½VéŠWY^Ûûp[šÌR¯	õ½ê%P|
`¾›"ß®972ŠnİHèÈD7?Zgİ¢¨q-ı³ŞèàHÊt¡xPÜ#XcY›‘¯°ªWİ]oö?®"_ş!šL;hmz|LÛk¨€+…ßLv§ƒ°ö[c”×DU4t™.‚o›/h’B»œR6c²3a9ˆyx=’êî T ºâşÕ,JÊ…İ*Pum,ôÖ"tÔÎ·¹eòè•7W~ïoG«İ·¡‚	@½²)_1QŠ!k‡‘ÜY‹æ;•;"íãâ‹“sûfM²bŸÇôÛ:öÊdõ&LÕŸúV5úıN`-gªµè­ƒNŞ+k“³ÌÚëyöÅúÿWdÎH'+Îl¹Ñ¢S³-ò¶î®—Yc¶såN4hz€'¼¯®*ñ®Åˆ·æÍ¤2·ZÑĞ®YÆ3¤Íòİd-ß«M*Ôá
ÜŞ¾Ä%œµBQ½bÙÕÕ–aB{ãª¾·Q©Yë•÷Ù0!Äó¨¦M«;¾tô«XİUÇ<5Ï¿ypPQ
+†\0Ü„ôÂ·#ı ğÆEÇ]±e”îšÁù zŞ± ¤¦³fÚQj™%—Š—'Ç/ áZÀx>ÁâØ³Œvôä?­UdjOÊ§°Gb"«Ò¤p„d"<¾ãe{”PFãÄŠè–)´MNÏaïàV™‹ëè4V
‹)°F½gU»l‚«%hë+qK%P˜GÁ¬Æª~A•¥ÓŠædZ…Û“(/†V«×©çXŸLE§:x¥ª½ùCÙ¹f‹…„(ÌRŸØÊ¬Ø™òóÛGfù’©,\÷IF“çN2ñ3¬’Vh‹ÆL“ã5TáîK…UŞq~5%=Ë:Æ<WÄA8apV\]cFGe¦e›y#6€­*bª*Ñ•¥¦ÀŒ‹JôsSYRm#ãã]U@ˆÅ&…ÙÁ;J 6UqvÅPU…qCñt*¶"”¬ˆ+ºhR_¾xö«åÇuùÖ¸–ø
±„—Å†EVˆû
qsB­dF¹d/^¾vU‰ÌÊs×|²<C=:£ÚÚ1—U9’’„ú!OûIĞ&×¡oâs¬! =Gµ ¼'UUókïQeÖ±)˜ãÆnÓá™ ÔA”YSåsô¾Õ˜ö÷h»9øËİÀŞìÓ» Ck¬ª¬Ás.>a*4™Ö¾ˆMºÛc÷}±«L¼Şµ ‘X­–4qƒÑ5ˆÚ{ú¬v_>T‰*‹İœ6CõKÍ×»._Şñ®iõ#ÛÅùqníFãßØ´;»%V×÷îxÇÆ²Wï …º÷%ëÄV2ãz8°Ì9-Ş&­]’¨PyÅVD;ôJ©´Á°Lƒœzø¡ş V¥Rä\2I]©²Iˆ\™^·ùÛR*°3]‚iP¹C>èFPi„iÇß¿®•7©«áÙÙ·OŸŸƒm]¨¬ì7x|ØßQÎù+âØ:„¹>ƒĞ³dÌo‡m	üØÚÖ¶rE§YŒ[L³ãDéJ¿:[Z™L\;Kq=í`gnµ•m±©‚j<Šai§TÎlGkG7EÎ®~2QºÁTí(OOğƒÓ?`š›³Õ½ğÜ´¥Ñ÷ş–NÚbëF”“/’öxëD¥A}§ÁhãCÉÜ&N„Åm¿*¤ÇW\Š</Àïb52Å ï%ùüIš˜˜ÌwÜÏ¦¶gÏBÇéXã‡` Q|x7ê`äk2•*H/€¹í‹.ş#ñJ‚ª¡´V°îfá8L~Ê£RönÒé@Ô‘¨](çv»ÉÅ¨<r¾·9Ä±VH*epœ¦6rÁô
 6mbNÏ]0µvl€]»`T§íÁ¹`tÊÃ×ÀØ04À2ŒŒ[á‚EÉ%“W»ªƒadİÄfA¾9k†%énBRmL_ÏÙ~l=Ùûz1J\ìªz[®!ÎÊzí«¾Véœé²a·‰]-ä`¿Fš8øKÀÁóMß/õGî”æšÅæˆÊJš"æ9ÖE&ŞYEÁz·J™}ìCåe›şµÅbläÂÉÍ~åÔ‹şe*£¦V'äÑ?=¶ßı¬Â­ªrˆ›c®wßşŠó+Ñ}ıó^ßDNÃE\:m'Òm]odl¢³¢ƒ<ÒÙyøk¦k¹N3G¬76 $+{;ëœsX¡ÈÑdRşí»*Ièórè¯Bë $Ã/©2	\X.f\pGŸàÕL--M_QRÈ¼ätP©+<N’“ÒôVıSÖ@4Ğ7ŞUtòØúø951¦‰šğ7C{k+c“ÕvüF—D	§‘WOiÀi¾¬ce:	ÅÓäRböÙil-ô<VÊ:%NMî‹ÇkCs¹êU‹eË	_,«AE·ÛÒ4–aÂí“T;]*M÷”xîJg?ª2ìÖóä“ZäºÚ6Çm²f\æ‰¡T¯ê« HM:—ìrÉ–šsüª:Ó1ŞN‰š7mĞ¯ÿjÒÌBaËJµÓz%Ç‹¼ ÑşF}MÁAkYµà
U7Ö'æ'Ä%­ŒÆ5jª™î†m
&¯ğjŒ¦Aj¶à¯BTè©¨äÆJ;ôä<+¯õrËÏ©”÷È_É0>	Ëó¥¢öÜM§šgÙRÂÌ#4#Œ§‹"Äcà½ş€I°¦Õµzµ£U!É%U="eIEª†+å\ ¨ãà#
8Cw~X…Ş-vÎ€†æxy›s¨Yèvëì³‘U<KĞüM•„XõeµF\z ñ7Ê¼{¡i nÕ]™òéÑÔ¾ÖÁÛ¸²¤¼kZYÓ¢VëbŠµÚ ~\cÊBìµ¨Ä‡¥’[3’Šô*q8–½ ì¬±ĞIÚ¨¦¥Ç]mm‰C±ƒjÊdSıCÓ~3ÍZõ¥òšÚìş®±dµ±ĞnõÈZ÷3B¶Ôô`4>OÅ=†¦,’˜Şğ³wş|2Y‹+<5F¼{@ª{¨"ÉÛÆ¤­}a)ãØñ·¯âÓFhêÆ³v‘Ãê‹†HÁn!Û+«rŒ“àU¾³Y™S˜ n¤9£ˆÍé²d˜î„.A)WB¬¦~Ú¶©ÖŠËØŞjÆ9W†Ùºù‡”nâiØÂV×-ØÃs4Ù³"–uÿmâÀÄ·ztè\ğ*¢”7K9 7ÃPØÔ¾ íçlf»°-ÕdfoùØLğ@ÑP;«í’»—§BtÈ±$)ñ'‘6ÃäÚ>ÂÖˆ”²„OuOoáTŸÁ‚$?C¦ök•~ğõYU<jö“k£(«JpóÜ­	ÕW¤QtşŒ^ûë~Â4&à ó¬Ê°«zÙ âÚ\S¥½[7°ş6zû€L5–wPÕÆy¬^¯Ø%÷§±Işmt¥Óä‹<ºßò¦Ó¾í£yµHjÁd³¹©™À•)f{@­xh#ÁXÒ×¹4– g§§ê)U¾lbC¥ÔF±Æ~uWP÷9g^t•@F« ‹×ôÖ/Çd¬íRÃÊ fUM±n¥6­‹<ŞÕ×†şv¢ßÎ#úËøpd4 JÄ¯	.3êR1âçÇ×…öá¡.è‘	§Î¡)ÀêÄ}5³<ÌÎ#'ÍSé“‘òïJ‹yG}ë s6ã6ÃZæz…â9$}4ÍSõp¡rH|ı¾õe¦VBíPíäz£I[äU‰7Şµkæ±ğ¥G7í»‘=¯]m]S‘U×MEŒVE}V³†}Í\Ê…Jï,^èÍÇzE•î+*uWÍZOÿ-m®®Pí§ZëÁ,õ^Y¦®Ú`øHİT]*d×*r§KŒ˜ğ±§–9”r~ßıµê¦–igcÚĞĞ4&	º|eB‰‘£F2å¶nº>!›.ÙS5.Jû­ƒêøbœ.°ÂZô»Şsr/“VCxW&à—¥½'ãÍ8­ŸmğçÍÎ»Ú±gùş+Ş~$ÔÎôŒù;*àdêH&öm8®—Ë (õ¯úv7:oÁ@;
ÄÔomb™0.ºÁ” ¯´ÙK2½ØŠís›yæù ¤…S›ı;mSû».ÖÇ•:…µM“¶İ!£|Ò ãw¾ëê	m©\}‚ºQIí&2¶ÓÕêä¬Ìçeä
~ËiOdó®?¡ŸNİ¡>4å.šU--;‡ú¯qş­SE‹²ÖùÜ«-×”Ş’8Ñ
˜dŸõCí˜§»jŸ7ñ+%ŒˆESé%«^HB‡	ùÆíÒíKQt]jØ×á«ù&Ùë¯A¾øâ‹-KÍj³3R×”˜8,O<êB/Ÿ8U*óÃ¸Wã«qš ;uGv¨"†Ã!õ¥#Ë UéÅ² fYä0‘H§•Q¢ïtBœ2™T–VEÛö‘š¶ §v¼{EìÂÔB—@Ñáa¯'‚µƒ–úH)=q‹½L<¬ïıöÄ"¶Ş¨³¥X'IWD$Şñ7ã‘c;YÓñ{'™®Ú¢{¬øl'ßs_R ªÀ¬ıêœBcse…£wÇi*d–9L‚w`d­:§­~Æ¹xO§˜Ù¾´•&¬§:NYDÀ(;(Lj—D_—àèÂk‚©¤R‹„[ÖµÈ7ÌÔ¹¢:¾¢ 7ˆø%j›-´ï›_!è™íÇ0ÆßF±y¯¼Éüÿñ‹u_¬½ŠpÔ¸EŒpëåƒµtàC³1K`ÍÙöÃ½KT3ãZ!£ÚØ]ndºåîõ¶ïò*Æ~«ìpyÕá’ºÀ?¦œ¯V²ò(áóõhîÔ¼YY›¡¤º?p	ŞóC™µÊ5[ãmæš/’Æ¥ce·WÉ°MAİ\Ûç˜¬m¢Ã>²&!I-‹„ÖAßåûª	YŠ¢­«ÒÑØn¶Íng™	—ôÙ+¯êÇ÷–œÓòõºÒ]Œ¾Í
¯³¨êù2–l{›8ÜÀş¹v¨É;ûF:Ü$‰V!%ëèw0zNt¬75-Ëm_Çrê.ÅÙµÄÁúeÊ7¨Ó½‰şÏì™ûN–Nş•øAgS[Õ?ôÅj–Ş:ö£‹9˜5ÍÁwk™X|t³¸Jù(ÁËÃåÁÎF¸y\u‘*mÂÆ«XgÓ±:‘ûß1³6ñÑ©â0¬ØÁb˜Ò¹9×§Ï[ÜnD„:¦¦RÓ®V™édt:d4İó	MÛ%˜Rù¬ŠXiP¶†ëë³ÚwcÍlÂ”ÊÕ³`ŞíÄ%û6]t½*lru]“ˆ%ÎĞNÃšöÙqê{qh{½/cÕQ>sXåÑÜæŞËØj°BY[ÆŞÔÕ'òYåâ€z×£µ{ÑQWêcùh‰ŒqâÄ*úáRHëçN¥µ†:`©]:´ºdğ¦4VÅ„‰´šÔ¨tŠ	;SÔ,Oô’ÒrÊ¦y=ÓšáK4KZM]*Ìáœµ,X¡[­®«Óâ[ÄTèj?·uƒH£u¸¦üã”@¼öêÈ±UoVEÍ¡5Õ÷×·0Tí#£à 9d¥š§°êw¤­ê³f²V®>âyQƒnıc”kœ<[OŸğ§¾Úr>Ğ€ÊÖjG£:hîÑ§9sóƒcUÀÏn£ª¥Ò|Ùõd”X#S€:QuØ/¨ğé_£ÛbD×˜.	ó2Sú‘,Nİƒt1ª‰BÎ‹R‡ÔtâÜ€”qhÃwx…ZƒõM‚-Ìu¾œ
å®­ÀQÊ–ºw9ıá¾œú,ä'ßQ‡İ¹7}0ïérö‘X8m|m‰iãd:ÍµOjnù)´ØŠ#äfPZ*b/àÿœj¯Eò1D®Ç¬'ÿ¦u¹äóÚ*ş­õ8$S*ó±ÂÌ¶èBÓÔÊ‹ç·°µsÌ#,[‹á ¹oòÕg‹Ÿ+™ğ4µÒ–ìs'¬¤dó¤yşÂ…¡i«ÃÌ×ËG›ZóIUhŞXñ/…8±XsÍÌ€¥ñD—ÌT°³Šñ-73¿]eÂ/ÌPÑ¥÷[õj.ü±²ö ì½Æ;xnÙÇ¶ğ=½¡¶Vhˆ—QÜä±ïùÆ>Şğ”ĞoWá<Ókqx õ4¿~‡»§ÊÆôè™÷l3¯µi²ôÃÆ`÷ÕP$§«µ¶jW8ŞöŒŒöô³^û¢9·iì®Œ Z2~Äw+Ñ!ˆ;
À­ùuòƒş( ™%tn;üsæ²îVWÆhÔÆ†I=xRÎ~ ²êçI¯è"FºÁ¹â’K²–xızçVi-ykúehÑ%³Ú"¢>Ç|;¿¼dÚ1ÏÙÍÕX.÷ÍæUİ‹4œ²cÁ»:åÙÃ)/1²ê‚×ÕÎ“•àE*ô+s]m îZ‰¨eî—¸Û†¯è¹=Æ/µxÜæÉ6´á<·_ ~í+?O:ïÔ³ÓÜpöí£r†å	;êÌ6¯ıÆ¯•.e"ãåÎ ÖtnĞÆtÙÕ·A›ºoS¥|ë»7×ñ`9ÌE­¦îMÚ\ˆ…F{ïJ’kÔ&ñ‡¥é'-)ÔRP^ƒ¿#èç8ßGıˆöm\@}NŸ+]¯æ”Êú:&ìç•tqÍ™ü#\@«àjğ-¸5k—XûÆÛ.ÖŞõŸÆÚ·µNnÀc\;Ûº®"P˜È¯ÊtÂ÷OğO¶Ïùzr.‡1ÕÒ†,Z[ÿôG•f:æ˜:­!j;h¤ê­ÉA/÷…åiêl‹;²¶ÉÛ<=ªóôáæº\\Í½u}š}KÍŸ¹şé)½í~ë{©jÌõök§là[uÙ‰Ñ/sB__W	<6ïYª~›‘v‰°@X­Xn`şkìªíÔ>]rwzÓêÛŒêş{øÔ´û·1ûíƒC“ïÊ‚©s°JVXq›şN¼‹uV[!¶R›	ux‹ª†„û{éV‚	Zá¥Æxpƒ7=åŸ¯C:ï]çJ>Õc‹
¡©ŒåÅËÇA#Çâ…%loú~xP®Ã1ŸvºÒÎĞ~QûNçğìïê¯}Ÿ×¾«Ÿô1ü¾û9xtˆ×é~ıó~ê;?HßåPZíwk™Äû÷´Àw[‡Q¡‹ä¤2ôŠ~­‡ÿ‘àF0eU«Sê•ùmÁk¶Ğ«L£ğè;İOõSA­Hp‹Ûƒ¹T¡iØzÅÿ%ã±F¡r‰‹V—ƒ^O©&XuXšTâvÌG@â¬x66:° 02rÂ?¬ÌRºh@>iÂ1Êe³_5	„;%-°Îá]£q¿•lä#6B²ñsjÆ¨Û ÁümQ˜1xÍrÚ>~6ûä<Êóö¦‡gùS±»³ÓÛúÍ>}·qëéÛšÅéˆJä„eûœùElŞ¦Ï©é¼Áu,ú²Æ¨¹®£6‹ÃV¬üïšˆ¾¾Äwí½’ÿ^ÈWp¼lsS~Öáß;&7â¢¥·Vn€e9ÖÖË*”GŸ€vçıy4>§«q Km°Á<¼êé1^åWX;âb"ùÍPûôã‹|IšË^ Pb<ü+¶„Û^Ò‡˜Ô]}7‰ï.ùÒÛC¼5Àå)Bºzt‹+ç.£<MæzG_”i…î!\“#µ(®#mqœB¸N(çgF#š³.ÿSEr5òÁ\áÙ\<Üüá<«¾W3Ê9,vòı‰æ8 ËÎ3ƒÏ‚!:j¯9Í6l>ì‹ğÁÃğïÓÏwÂ½/Æ>ÿâÁÃaø·‡~¾7ùûŞ'Ó‡ŸMÄ¦:ƒFUàÇÿóÚÁeğØî^‘f8x&ˆ~¯¯İ´1<u0±ë³èGwø|òOœÓU5ÂÓÎöz	”&’!~zÒ‹íÛ&	¤íÇ¹	vhC?ŠÈM
ıkxU¡YQçí¿Ò¸:@‹Ç|jû=â9³™%ç‚oDpm¸'´¼luÍ¯ééhÄéóÀØÖ‹¾ÙÃ¼ŸŞ­Äjg#Îğ2N «¨Kt£—0¾@Òµ¬“ É×¿?T9tÜûdkó7ì÷C!Ä'XvüµÁ!¸†vÖ0óî¨ïü/TÛnÚ@}¶¿b°“@HúR9W
$ :a^*U²6f°W2¶5»Nˆšü{g¹$h‘ÌÊ3çÌœ9;pyS$…mŸÁíB¦sIéœ^4!J$ø¥-³È†È,¦¼,`°Ë"EUIâ¢T(ı}ÆôQM¯P¢ÔIN ‚¢RÁ·)Æuj.4Î;/Ğ2ÇW›T0ñ9h‘ÍÍa2œ€/IĞgOkİDÁNĞFèbÌÌB7èF“(íf3¼ú—ì'$%óÎÚg•š ®4fsSŒJf=m3[~Û–™¦—gJSiXP¾…ĞIÛ¶LÃBXBÃDöµæ°¾'4¨SÛZ”Y¤°0Œ6ÕœŠåÚ·±¸fÚóöó¶2|Ş	ì‰(ag7ú*À{Ä_Ö®›œ@xŞ÷ÁÏ°„w#0î>ªªîIu|èèy½®ï‡³Ál:ß¿~’õ†áı`ö†#¿oo+mæşwš3º¶õf¯M¾%Ô%e –jĞ€).ÍY.ä
çğ,Ùæw¢>\sÚ×†Y¸‚f“{Y¾v§‘^u. ‘Â%4t"Uë:FİÇB'kâÇÇ.jÍm_íÁ‚òqçlê¶®¡Æ¼H7Ğ|…&xü@ÕìŸz¨º÷şßJ­ªÒ¯VÓ­îÁbònê<ĞÄWáì{ÚcÂ˜·PU¶ÊŒb°ùùd3Eš:81Í‹­jë1 ,Rh@¡ /Îúûsq.2PwW°’Ço®ÿ …PKOÂ@>wÅ<ˆAz1ÕˆÚ‹§fÙtÜ6»[Qş»Ëƒ{™ì÷˜ùfZyšR¿¹—_ $\"Ó™ÜÌ%ÍS®QRó«qÁs™9xkú™/PYp*9Î€-¨RĞ=úû;¿ğ[-tšI€!•¬Pğš¡œãJ¨F0ï®Ñ¸‡Û]y0ø
ÇBMEBeãÁ>•Tn[?$¿
 Z"ÂqĞ)Õ‰ÅTš­T¹1GUû/ç¥â™€f­iÇ_Úp­Q$'tdr”ù"Î¬LïÚÅ1Ë„Ò²`úú*§:­ÇğÎYa.K×±ºî©Å(+(åÊRs“£Ú
¬bL%
}Ÿ[Ë°¥Èª^P¸î›÷·Ã¸çŞ¨=ôöm+¶Tª¶üJäºvÄÑ{MüQÿû:êâ¾ÅtIÙ)·¸nè=3pF­<gK¶„´ ’AOƒ@…Ïì¯˜£6±T/šØXk/zhÒØ`¦0ÀÆe!³»¨!şwª©mH[.dŞ÷æí[ÂtVµRñh¤`™6u<Ö6éms®B+{aÃš2H:·1ø¢b€%r<UÄ9mQŠ@›Éä®º×èê¶aQ•%ÚTæXÅ1´mû/èÓ“Mex^½Í9)tC]{Ş[»éXWØzuY*Ézôº²§j7ÄNlp=ôİ—Ú…;x¥$ÈnC/}ÅªUQlÒ9ùµÎ-úÀtq©"a“L24îUô­öıs£ÑãeúĞ6ıuî‘NÏ‰ê,·Êx§¯!ÙÊçÒt‹B›TâÎ¼çı0mIågÂ!,Û'ğÚ‡ÍrHàìá²º	¶¥Dò´oév&GÂ\   GBMB